<!DOCTYPE html>
<html lang="sr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Najbolje iz Vojvodine ‚Äì mapa</title>

    <!-- MapLibre -->
    <link
      href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

    <style>
      :root {
        --fg: #1a1a1a;
        --muted: #5d5d5d;
        --accent: #1f7a8c;
        --card-w: 260px;
        --radius: 14px;
        --pad: 12px;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      #map {
        height: 100vh;
        width: 100vw;
      }

      .badge {
        position: absolute;
        left: 12px;
        top: 12px;
        z-index: 10;
        background: rgba(255, 255, 255, 0.92);
        border-radius: 10px;
        padding: 6px 10px;
        font: 13px/1.35 system-ui, Arial;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
      }

      /* ===== modern marker styles ===== */
      .modern-marker {
        position: relative;
        cursor: pointer;
        user-select: none;
        pointer-events: auto;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .modern-marker:hover {
        transform: scale(1.1);
        z-index: 1000;
      }

      /* Pulse animation for markers */
      @keyframes markerPulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.4);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 8px 4px rgba(0, 0, 0, 0.2);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.4);
        }
      }

      /* Add pulse effect to symbol layer markers on hover */
      .maplibregl-canvas-container:hover {
        cursor: pointer;
      }

      .marker-pin {
        width: 32px;
        height: 32px;
        border-radius: 50% 50% 50% 0;
        transform: rotate(-45deg);
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        border: 3px solid rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        margin: 0 auto;
      }

      .marker-icon {
        transform: rotate(45deg);
        font-size: 14px;
        filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
      }

      .marker-shadow {
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 8px;
        background: radial-gradient(
          ellipse,
          rgba(0, 0, 0, 0.2) 0%,
          transparent 70%
        );
        border-radius: 50%;
        filter: blur(2px);
      }

      .modern-marker:hover .marker-pin {
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2), 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .modern-marker:hover .marker-shadow {
        transform: translateX(-50%) scale(1.2);
        opacity: 0.8;
      }

      /* ===== modern glassmorphism popup ===== */
      .maplibregl-popup {
        max-width: 280px !important;
      }
      .maplibregl-popup-content {
        padding: 0;
        border-radius: 20px;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1),
          0 8px 16px rgba(0, 0, 0, 0.05);
        animation: popupSlideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        max-height: 500px;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .maplibregl-popup-close-button {
        top: 12px;
        right: 12px;
        background: rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        color: #666;
        transition: all 0.2s ease;
      }
      .maplibregl-popup-close-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      @keyframes popupSlideIn {
        from {
          opacity: 0;
          transform: translateY(-10px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      .card {
        width: 280px;
        max-height: 400px;
        overflow-y: auto;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        scrollbar-width: thin;
        scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
      }

      .card::-webkit-scrollbar {
        width: 6px;
      }

      .card::-webkit-scrollbar-track {
        background: transparent;
      }

      .card::-webkit-scrollbar-thumb {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
      }

      .card::-webkit-scrollbar-thumb:hover {
        background: rgba(0, 0, 0, 0.3);
      }

      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
      }

      .card_media {
        position: relative;
        background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        overflow: hidden;
      }

      .card_img {
        display: block;
        width: 100%;
        height: 180px;
        object-fit: cover;
        transition: transform 0.3s ease;
      }

      .card_media:hover .card_img {
        transform: scale(1.05);
      }

      .card_body {
        padding: 20px;
        font: 14px/1.5 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        color: #1a202c;
      }

      .card_title {
        margin: 0 0 8px;
        font-size: 18px;
        font-weight: 700;
        color: #2d3748;
        line-height: 1.3;
      }

      .muted {
        color: #718096;
        font-size: 13px;
        margin: 4px 0;
      }

      .card_link {
        color: #3182ce;
        text-decoration: none;
        font-weight: 600;
        font-size: 13px;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 4px;
      }

      .card_link:hover {
        color: #2c5282;
        transform: translateX(2px);
      }

      .card_link::after {
        content: "‚Üó";
        font-size: 12px;
        transition: transform 0.2s ease;
      }

      .card_link:hover::after {
        transform: translate(2px, -2px);
      }

      /* ===== Map Controls ===== */
      .map-controls {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 280px;
      }

      .search-container {
        position: relative;
        display: flex;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 4px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        align-items: center;
        z-index: 100;
      }

      #searchInput {
        flex: 1;
        border: none;
        background: transparent;
        padding: 6px 12px;
        font-size: 13px;
        outline: none;
        color: #333;
        min-width: 0;
      }

      #searchInput::placeholder {
        color: #666;
        font-size: 12px;
      }

      #searchBtn {
        background: #3182ce;
        border: none;
        border-radius: 16px;
        padding: 6px 10px;
        color: white;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
        margin-left: 4px;
        min-width: 32px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #searchBtn:hover {
        background: #2c5282;
        transform: scale(1.05);
      }

      /* Autocomplete Dropdown */
      .search-dropdown {
        position: absolute;
        top: calc(100% + 8px);
        left: 0;
        right: 0;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        border: 1px solid rgba(0, 0, 0, 0.08);
        max-height: 320px;
        overflow-y: auto;
        display: none;
        z-index: 2000;
      }

      .search-dropdown.active {
        display: block;
      }

      .dropdown-item {
        padding: 10px 14px;
        cursor: pointer;
        transition: background 0.15s ease;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        align-items: center;
        gap: 8px;
        background: #ffffff;
        position: relative;
        z-index: 1;
      }

      .dropdown-item:last-child {
        border-bottom: none;
      }

      .dropdown-item:hover,
      .dropdown-item.highlighted {
        background: rgba(49, 130, 206, 0.1);
      }

      .dropdown-item-name {
        font-weight: 600;
        font-size: 13px;
        color: #333;
      }

      .dropdown-item-location {
        font-size: 11px;
        color: #666;
        margin-left: auto;
      }

      .dropdown-item-category {
        display: inline-block;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .dropdown-empty {
        padding: 16px;
        text-align: center;
        color: #999;
        font-size: 12px;
      }

      .category-filters {
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        position: relative;
        z-index: 1;
      }

      .filter-row {
        display: flex;
        gap: 6px;
        justify-content: center;
      }

      .filter-btn {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 16px;
        padding: 6px 12px;
        font-size: 11px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #666;
        white-space: nowrap;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .filter-btn svg {
        width: 14px;
        height: 14px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
      }

      .filter-btn.active svg {
        opacity: 1;
      }

      .filter-btn:hover {
        background: rgba(255, 255, 255, 1);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .filter-btn.active {
        background: #3182ce;
        color: white;
        border-color: #3182ce;
      }

      .filter-btn[data-category="Zanat"].active {
        background: #f4a261;
        border-color: #f4a261;
      }

      .filter-btn[data-category="Proizvodi"].active {
        background: #8b4513;
        border-color: #8b4513;
      }

      .filter-btn[data-category="Usluge"].active {
        background: #20b2aa;
        border-color: #20b2aa;
      }

      .filter-btn[data-category="Manifestacije"].active {
        background: #dc143c;
        border-color: #dc143c;
      }

      /* carousel kontrole */
      .navbtn {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 26px;
        height: 26px;
        border: none;
        border-radius: 99px;
        background: rgba(255, 255, 255, 0.95);
        display: grid;
        place-items: center;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
        cursor: pointer;
      }
      .navbtn--prev {
        left: 8px;
      }
      .navbtn--next {
        right: 8px;
      }
      .dots {
        position: absolute;
        left: 0;
        right: 0;
        bottom: 6px;
        display: flex;
        gap: 6px;
        justify-content: center;
      }
      .dots i {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.7);
      }
      .dots i.on {
        background: #fff;
      }

      /* Logo watermark */
      .logo-watermark {
        position: absolute;
        bottom: 10px;
        right: 10px;
        width: 110px;
        opacity: 0.85;
        pointer-events: none;
        z-index: 1;
        transition: opacity 0.3s ease;
      }

      .logo-watermark:hover {
        opacity: 1;
      }

      .logo-watermark img {
        width: 100%;
        height: auto;
        display: block;
        filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.15));
      }

      /* Fullscreen/Open button */
      .fullscreen-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(0, 0, 0, 0.1);
        border-radius: 16px;
        padding: 8px 14px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
        display: flex;
        align-items: center;
        gap: 6px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      .fullscreen-btn:hover {
        background: rgba(255, 255, 255, 1);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      .fullscreen-btn svg {
        width: 14px;
        height: 14px;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- Logo Watermark -->
    <div class="logo-watermark">
      <img src="img/niv-logo.png" alt="Najbolje iz Vojvodine" />
    </div>

    <!-- Fullscreen/Open in New Window Button -->
    <button class="fullscreen-btn" id="fullscreenBtn" title="Otvori u celom ekranu">
      <svg viewBox="0 0 16 16" fill="currentColor">
        <path d="M2 2h4v1H3v3H2V2zm10 0h4v4h-1V3h-3V2zM2 12v-4h1v3h3v1H2zm10 0v1h4v-4h-1v3h-3z"/>
        <path d="M5 5h6v6H5z" opacity="0.5"/>
      </svg>
      Cela mapa
    </button>

    <!-- Search and Filter Controls -->
    <div class="map-controls">
      <div class="search-container">
        <input
          type="text"
          id="searchInput"
          placeholder="Pretra≈æi lokacije..."
          autocomplete="off"
        />
        <button id="searchBtn">üîç</button>
        <div class="search-dropdown" id="searchDropdown"></div>
      </div>

      <div class="category-filters">
        <div class="filter-row">
          <button class="filter-btn active" data-category="all">
            <svg viewBox="0 0 16 16" fill="currentColor">
              <rect x="2" y="2" width="5" height="5" rx="1"/>
              <rect x="9" y="2" width="5" height="5" rx="1"/>
              <rect x="2" y="9" width="5" height="5" rx="1"/>
              <rect x="9" y="9" width="5" height="5" rx="1"/>
            </svg>
            Sve
          </button>
          <button class="filter-btn" data-category="Zanat">
            <svg viewBox="0 0 16 16" fill="currentColor">
              <!-- Hammer head (rectangle) -->
              <rect x="4" y="3.5" width="8" height="4" rx="0.5"/>
              <!-- Hammer handle (vertical) -->
              <rect x="7" y="6.5" width="2" height="8" rx="0.5"/>
            </svg>
            Zanati
          </button>
          <button class="filter-btn" data-category="Proizvodi">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <!-- Shopping bag -->
              <rect x="4" y="6" width="8" height="8" rx="1"/>
              <!-- Bag handles -->
              <path d="M6 6 L6 5 C6 3.9 6.9 3 8 3 C9.1 3 10 3.9 10 5 L10 6"/>
            </svg>
            Proizvodi
          </button>
        </div>
        <div class="filter-row">
          <button class="filter-btn" data-category="Usluge">
            <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <!-- Wrench head (circle) -->
              <circle cx="6" cy="5.5" r="3"/>
              <!-- Wrench handle (diagonal line) -->
              <line x1="8" y1="8" x2="12" y2="12"/>
            </svg>
            Usluge
          </button>
          <button class="filter-btn" data-category="Manifestacije">
            <svg viewBox="0 0 16 16" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
              <!-- Flag pole (vertical line) -->
              <line x1="4" y1="2" x2="4" y2="14" fill="none"/>
              <!-- Flag pennant (triangular) -->
              <path d="M4 2 L12 5 L4 8 Z"/>
            </svg>
            Manifestacije
          </button>
        </div>
      </div>
    </div>

    <script>
      // 1) Map style (MapTiler) - Analysis: We're using MapTiler for:
      // - Base map tiles (satellite/street view)
      // - Geocoding (in csv2geojson.js)
      // - Map styling and themes
      // Alternative: OpenStreetMap (free) or Mapbox (paid)
      const MAPTILER_KEY = "WJJJqPPstboZWo4827qc";
      const STYLE_URL = `https://api.maptiler.com/maps/streets-v2/style.json?key=${MAPTILER_KEY}`;

      // Alternative free map styles:
      // const STYLE_URL = 'https://api.maptiler.com/maps/basic-v2/style.json?key=' + MAPTILER_KEY;
      // const STYLE_URL = 'https://api.maptiler.com/maps/outdoor-v2/style.json?key=' + MAPTILER_KEY;
      // const STYLE_URL = 'https://api.maptiler.com/maps/satellite/style.json?key=' + MAPTILER_KEY;

      // 2) Init mapa
      const map = new maplibregl.Map({
        container: "map",
        style: STYLE_URL,
        center: [19.8335, 45.2671],
        zoom: 7.2,
        attributionControl: true,
      });
      map.addControl(new maplibregl.NavigationControl(), "top-right");

      // 3) Uƒçitavanje podataka
      async function loadData() {
        const r = await fetch("/data/places.geojson", { cache: "no-store" });
        if (!r.ok) throw new Error("Ne mogu da uƒçitam /data/places.geojson");
        return r.json();
      }

      // 4) INLINE SVG MARKERA (popunjen, kontrastan)
      //   ‚Äì nema fetch-a ‚Üí nema CORS/404; lako menja≈° boje/veliƒçinu
      const PIN_SVG = `
        <svg viewBox="0 0 40 52" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <defs>
            <linearGradient id="pinGradient" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0" stop-color="#1f7a8c"/>
              <stop offset="1" stop-color="#176273"/>
            </linearGradient>
          </defs>
          <!-- telo pina - puno, bez providnosti -->
          <path d="M20 1C10.1 1 2 9.1 2 19c0 10.3 9 19.5 16.2 30.7a2 2 0 0 0 3.5 0C29 38.5 38 29.3 38 19 38 9.1 29.9 1 20 1z"
                fill="url(#pinGradient)" stroke="#0e3d45" stroke-width="2"/>
          <!-- bela ploƒçica unutra -->
          <circle cx="20" cy="19" r="10.5" fill="#ffffff" stroke="#0e3d45" stroke-width="1.5"/>
          <!-- alatke (ikonica zanata) -->
          <path d="M16.2 14.5l-3 2.8a.9.9 0 0 0 0 1.3l2 2a.9.9 0 0 0 1.3 0l2.8-3 4.7 4.7a1 1 0 0 0 1.4 0l1-1a1 1 0 0 0 0-1.4l-4.8-4.7 3-2.9a.9.9 0 0 0 0-1.3l-2-2a.9.9 0 0 0-1.2 0l-2.9 3-2-2a.9.9 0 0 0-1.3 0l-1 1a.9.9 0 0 0 0 1.3l2 1.9z"
                fill="#0e3d45"/>
        </svg>`;

      // Test marker - simple red circle
      const TEST_MARKER = `
        <div style="width: 30px; height: 30px; background: red; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>
      `;

      // Modern marker design with category colors
      const createModernMarker = (category) => {
        const colors = {
          Zanat: { primary: "#F4A261", secondary: "#E76F51", icon: "üî®" }, // Saffron
          Proizvodi: { primary: "#8B4513", secondary: "#A0522D", icon: "üì¶" }, // Chestnut
          Usluge: { primary: "#20B2AA", secondary: "#40E0D0", icon: "üõ†Ô∏è" }, // Teal
          Manifestacije: {
            primary: "#DC143C",
            secondary: "#FF6347",
            icon: "üé°",
          }, // Carmine
          default: { primary: "#1F7A8C", secondary: "#4A9BB5", icon: "üìç" },
        };

        const color = colors[category] || colors.default;

        // Use emoji icons for all categories

        return `
          <div class="modern-marker" data-category="${category}">
            <div class="marker-pin" style="
              background: linear-gradient(135deg, ${color.primary} 0%, ${color.secondary} 100%);
              box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.1);
            ">
              <div class="marker-icon">${color.icon}</div>
            </div>
            <div class="marker-shadow"></div>
          </div>
        `;
      };

      // Cache busting for development
      console.log("NIV Map loaded - version:", new Date().toISOString());

      // helper: normalizuj CSV foto listu ‚Üí apsolutni put
      // SAMO fotke iz CSV/GeoJSON (bez fallbacka)
      const normPhotos = (fotoString) => {
        if (!fotoString) return [];
        return String(fotoString)
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean)
          .filter((u) => /\.(png|jpe?g|webp|gif|svg)$/i.test(u))
          .map((u) => (u.startsWith("/") ? u : `/${u}`));
      };

      // popup HTML + carousel
      function buildCarousel(arr, alt) {
        if (!arr.length) return "";
        const dots = arr
          .map((_, i) => `<i class="${i === 0 ? "on" : ""}"></i>`)
          .join("");
        return `
          <div class="card_media" data-count="${arr.length}">
            <img class="card_img" src="${arr[0]}" alt="${
          alt || "Foto"
        }" data-idx="0"/>
            ${
              arr.length > 1
                ? `
              <button class="navbtn navbtn--prev" aria-label="Prethodna">‚Äπ</button>
              <button class="navbtn navbtn--next" aria-label="Sledeƒáa">‚Ä∫</button>
              <div class="dots">${dots}</div>`
                : ""
            }
          </div>`;
      }
      function popupHTML(p) {
        const photos = normPhotos(p.foto);
        return `
          <article class="card">
            ${buildCarousel(photos, p.naziv)}
            <div class="card_body">
              <h3 class="card_title">${p.naziv ?? ""}</h3>
              ${
                p.kategorija
                  ? `<div class="muted"><strong>Kategorija:</strong> ${p.kategorija}</div>`
                  : ""
              }
              ${
                p.opis
                  ? `<p class="muted" style="margin:.45rem 0 0">${p.opis}</p>`
                  : ""
              }
              ${
                p.web
                  ? `<p style="margin:.55rem 0 0"><a class="card_link" href="${p.web}" target="_blank" rel="noopener">Web sajt ‚áó</a></p>`
                  : ""
              }
            </div>
          </article>`;
      }
      function wireCarousel(container, items) {
        const wrap = container.querySelector(".card_media");
        if (!wrap) return;
        const img = wrap.querySelector(".card_img");
        const prev = wrap.querySelector(".navbtn--prev");
        const next = wrap.querySelector(".navbtn--next");
        const dots = wrap.querySelectorAll(".dots i");
        let idx = 0;
        let startX = 0;
        let startY = 0;
        let isDragging = false;

        const go = (to) => {
          idx = (to + items.length) % items.length;
          img.src = items[idx];
          img.dataset.idx = String(idx);
          dots.forEach((d, i) => d.classList.toggle("on", i === idx));
        };

        // Touch/swipe support for mobile
        wrap.addEventListener("touchstart", (e) => {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
          isDragging = true;
        });

        wrap.addEventListener("touchmove", (e) => {
          if (!isDragging) return;
          e.preventDefault();
        });

        wrap.addEventListener("touchend", (e) => {
          if (!isDragging) return;
          isDragging = false;

          const endX = e.changedTouches[0].clientX;
          const endY = e.changedTouches[0].clientY;
          const diffX = startX - endX;
          const diffY = startY - endY;

          // Only trigger swipe if horizontal movement is greater than vertical
          if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
            if (diffX > 0) {
              go(idx + 1); // Swipe left - next image
            } else {
              go(idx - 1); // Swipe right - previous image
            }
          }
        });

        // Mouse drag support for desktop
        wrap.addEventListener("mousedown", (e) => {
          startX = e.clientX;
          isDragging = true;
          e.preventDefault();
        });

        wrap.addEventListener("mousemove", (e) => {
          if (!isDragging) return;
          e.preventDefault();
        });

        wrap.addEventListener("mouseup", (e) => {
          if (!isDragging) return;
          isDragging = false;

          const endX = e.clientX;
          const diffX = startX - endX;

          if (Math.abs(diffX) > 50) {
            if (diffX > 0) {
              go(idx + 1);
            } else {
              go(idx - 1);
            }
          }
        });

        // Button controls
        prev &&
          prev.addEventListener("click", (e) => {
            e.stopPropagation();
            go(idx - 1);
          });
        next &&
          next.addEventListener("click", (e) => {
            e.stopPropagation();
            go(idx + 1);
          });
        dots.forEach((d, i) =>
          d.addEventListener("click", (e) => {
            e.stopPropagation();
            go(i);
          })
        );
      }

      map.on("load", async () => {
        const data = await loadData();
        const popup = new maplibregl.Popup({
          closeButton: true,
          closeOnClick: true,
        });

        // Create custom pin images for stable Symbol Layer markers
        // Hybrid design: White icons on brand green + colored category dot
        const createCustomPin = (category) => {
          const brandGreen = "#00A651"; // Official "Najbolje iz Vojvodine" logo green
          const categoryColors = {
            Zanat: "#F4A261",      // Orange
            Proizvodi: "#8B4513",  // Brown
            Usluge: "#20B2AA",     // Teal
            Manifestacije: "#DC143C", // Red
            default: "#1F7A8C"
          };

          const categoryColor = categoryColors[category] || categoryColors.default;

          const canvas = document.createElement('canvas');
          const width = 32;
          const height = 42;
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');

          // Enable anti-aliasing for smooth edges
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = 'high';

          const centerX = width / 2;
          const circleCenterY = 13;
          const circleRadius = 12;

          // Draw drop shadow
          ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
          ctx.shadowBlur = 8;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 4;

          // Draw the teardrop shape
          ctx.beginPath();

          // Top circle part
          ctx.arc(centerX, circleCenterY, circleRadius, 0, 2 * Math.PI);

          // Bottom point (create triangle from circle bottom to tip)
          ctx.moveTo(centerX - circleRadius * 0.5, circleCenterY + circleRadius - 2);
          ctx.lineTo(centerX, height - 4);
          ctx.lineTo(centerX + circleRadius * 0.5, circleCenterY + circleRadius - 2);

          // Fill with brand green
          ctx.fillStyle = brandGreen;
          ctx.fill();

          // Reset shadow for inner elements
          ctx.shadowColor = 'transparent';
          ctx.shadowBlur = 0;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;

          // Set white color for all icons
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Draw category-specific icon in white
          if (category === 'Zanat') {
            // Hammer icon
            const hammerScale = 0.7;
            const hx = centerX;
            const hy = circleCenterY;

            // Hammer head (rectangle)
            ctx.fillRect(hx - 4 * hammerScale, hy - 5 * hammerScale, 8 * hammerScale, 4 * hammerScale);

            // Hammer handle
            ctx.fillRect(hx - 1 * hammerScale, hy - 1 * hammerScale, 2 * hammerScale, 8 * hammerScale);

          } else if (category === 'Proizvodi') {
            // Shopping bag icon
            const bagScale = 0.7;
            const bx = centerX;
            const by = circleCenterY;

            // Shopping bag body (rounded rectangle)
            const bagWidth = 8 * bagScale;
            const bagHeight = 8 * bagScale;
            const bagX = bx - bagWidth / 2;
            const bagY = by - bagHeight / 2 + 1 * bagScale;
            const radius = 1 * bagScale;

            ctx.beginPath();
            ctx.moveTo(bagX + radius, bagY);
            ctx.lineTo(bagX + bagWidth - radius, bagY);
            ctx.arcTo(bagX + bagWidth, bagY, bagX + bagWidth, bagY + radius, radius);
            ctx.lineTo(bagX + bagWidth, bagY + bagHeight - radius);
            ctx.arcTo(bagX + bagWidth, bagY + bagHeight, bagX + bagWidth - radius, bagY + bagHeight, radius);
            ctx.lineTo(bagX + radius, bagY + bagHeight);
            ctx.arcTo(bagX, bagY + bagHeight, bagX, bagY + bagHeight - radius, radius);
            ctx.lineTo(bagX, bagY + radius);
            ctx.arcTo(bagX, bagY, bagX + radius, bagY, radius);
            ctx.stroke();

            // Shopping bag handles (curved arcs)
            ctx.beginPath();
            // Left handle
            ctx.moveTo(bx - 2 * bagScale, bagY);
            ctx.lineTo(bx - 2 * bagScale, bagY - 1 * bagScale);
            ctx.arcTo(bx - 2 * bagScale, bagY - 3 * bagScale, bx, bagY - 3 * bagScale, 2 * bagScale);
            ctx.arcTo(bx + 2 * bagScale, bagY - 3 * bagScale, bx + 2 * bagScale, bagY - 1 * bagScale, 2 * bagScale);
            ctx.lineTo(bx + 2 * bagScale, bagY);
            ctx.stroke();

          } else if (category === 'Usluge') {
            // Wrench icon
            const wrenchScale = 0.7;
            const wx = centerX;
            const wy = circleCenterY;

            // Wrench head (circle)
            ctx.beginPath();
            ctx.arc(wx - 2 * wrenchScale, wy - 3 * wrenchScale, 3 * wrenchScale, 0, 2 * Math.PI);
            ctx.stroke();

            // Wrench handle
            ctx.beginPath();
            ctx.moveTo(wx, wy);
            ctx.lineTo(wx + 4 * wrenchScale, wy + 4 * wrenchScale);
            ctx.stroke();

          } else if (category === 'Manifestacije') {
            // Festival Flag icon
            const flagScale = 0.8;
            const fx = centerX;
            const fy = circleCenterY;

            // Flag pole
            ctx.beginPath();
            ctx.moveTo(fx - 4 * flagScale, fy - 5 * flagScale);
            ctx.lineTo(fx - 4 * flagScale, fy + 5 * flagScale);
            ctx.lineWidth = 2;
            ctx.stroke();

            // Flag (triangular pennant)
            ctx.beginPath();
            ctx.moveTo(fx - 4 * flagScale, fy - 5 * flagScale);
            ctx.lineTo(fx + 4 * flagScale, fy - 2 * flagScale);
            ctx.lineTo(fx - 4 * flagScale, fy + 1 * flagScale);
            ctx.closePath();
            ctx.fill();

          } else {
            // Default: Location pin icon
            ctx.beginPath();
            ctx.arc(centerX, circleCenterY - 1, 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(centerX, circleCenterY + 2);
            ctx.lineTo(centerX, circleCenterY + 5);
            ctx.lineWidth = 2;
            ctx.stroke();
          }

          // Draw small colored dot at bottom of teardrop for category distinction
          const dotY = circleCenterY + circleRadius - 5;
          ctx.beginPath();
          ctx.arc(centerX, dotY, 2, 0, 2 * Math.PI); // 4px diameter (2px radius)
          ctx.fillStyle = categoryColor;
          ctx.fill();

          // Add white border to dot for visibility
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 0.5;
          ctx.stroke();

          return canvas.toDataURL('image/png');
        };

        // Store all markers for search functionality
        const allMarkers = [];
        let currentTooltip = null;

        // Create custom pin images and add to map
        const categories = ['Zanat', 'Proizvodi', 'Usluge', 'Manifestacije'];

        // Track loaded images
        let imagesLoaded = 0;
        const totalImages = categories.length;

        // Load all images and wait for them to complete
        const imagePromises = categories.map(category => {
          return new Promise((resolve) => {
            const pinImage = createCustomPin(category);
            const img = new Image();
            img.onload = () => {
              map.addImage(`pin-${category.toLowerCase()}`, img);
              imagesLoaded++;
              console.log(`Loaded image: pin-${category.toLowerCase()} (${imagesLoaded}/${totalImages})`);
              resolve();
            };
            img.onerror = (err) => {
              console.error(`Failed to load image for ${category}:`, err);
              resolve(); // Resolve anyway to not block other images
            };
            img.src = pinImage;
          });
        });

        // Wait for all images to load before adding source and layer
        await Promise.all(imagePromises);

        console.log('All marker images loaded successfully');

        // City-based semantic clustering
        // Group markers by city and create city clusters for cities with 3+ markers
        const cityClusters = {};
        const individualMarkers = [];

        data.features.forEach(feature => {
          const city = feature.properties.mesto || 'Unknown';
          if (!cityClusters[city]) {
            cityClusters[city] = [];
          }
          cityClusters[city].push(feature);
        });

        // Create city cluster points and separate individual markers
        const cityClusterFeatures = [];
        const clusteredCityMarkers = [];

        Object.entries(cityClusters).forEach(([city, features]) => {
          if (features.length >= 2) {
            // Create cluster for cities with 2+ markers
            const centroid = features.reduce((acc, f) => {
              acc.lng += f.geometry.coordinates[0];
              acc.lat += f.geometry.coordinates[1];
              return acc;
            }, { lng: 0, lat: 0 });

            centroid.lng /= features.length;
            centroid.lat /= features.length;

            // Collect unique categories in this cluster
            const categories = [...new Set(features.map(f => f.properties.kategorija))];

            cityClusterFeatures.push({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [centroid.lng, centroid.lat]
              },
              properties: {
                city: city,
                count: features.length,
                bounds: features.map(f => f.geometry.coordinates),
                categories: categories.join(',') // Store as comma-separated string
              }
            });

            // Also store the individual markers for this clustered city
            clusteredCityMarkers.push(...features);
          } else {
            // Add to individual markers
            individualMarkers.push(...features);
          }
        });

        // Add source for individual markers (cities with 1-2 locations)
        map.addSource('places', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: individualMarkers
          },
          generateId: true
        });

        // Add source for city clusters (cities with 3+ locations)
        map.addSource('city-clusters', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: cityClusterFeatures
          }
        });

        // Add source for markers from clustered cities (show when zoomed in)
        map.addSource('clustered-city-markers', {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: clusteredCityMarkers
          },
          generateId: true
        });

        // Add city cluster circle layer (only visible when zoomed out)
        map.addLayer({
          id: 'city-clusters-circles',
          type: 'circle',
          source: 'city-clusters',
          maxzoom: 10, // Hide when zoomed in past level 10
          paint: {
            'circle-color': '#00A651', // Brand green
            'circle-radius': [
              'interpolate',
              ['linear'],
              ['get', 'count'],
              2, 22,  // 2 markers = 22px
              6, 32   // 6+ markers = 32px
            ],
            'circle-stroke-width': 2,
            'circle-stroke-color': '#ffffff',
            'circle-opacity': 0.9
          }
        });

        // Add city cluster label layer (only visible when zoomed out)
        map.addLayer({
          id: 'city-clusters-labels',
          type: 'symbol',
          source: 'city-clusters',
          maxzoom: 10, // Hide when zoomed in past level 10
          layout: {
            'text-field': ['concat', ['get', 'city'], '\n', ['get', 'count']],
            'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
            'text-size': 10,
            'text-allow-overlap': true,
            'text-anchor': 'center'
          },
          paint: {
            'text-color': '#ffffff',
            'text-halo-color': 'rgba(0, 166, 81, 0.8)',
            'text-halo-width': 1
          }
        });

        // Add individual marker symbol layer (cities with 1-2 markers - always visible)
        map.addLayer({
          id: 'places-symbols',
          type: 'symbol',
          source: 'places',
          layout: {
            'icon-image': [
              'case',
              ['==', ['get', 'kategorija'], 'Zanat'], 'pin-zanat',
              ['==', ['get', 'kategorija'], 'Proizvodi'], 'pin-proizvodi',
              ['==', ['get', 'kategorija'], 'Usluge'], 'pin-usluge',
              ['==', ['get', 'kategorija'], 'Manifestacije'], 'pin-manifestacije',
              'pin-zanat' // default
            ],
            'icon-size': 1,
            'icon-anchor': 'bottom',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true
          }
        });

        // Add clustered city markers layer (cities with 3+ markers - only visible when zoomed in)
        map.addLayer({
          id: 'clustered-city-symbols',
          type: 'symbol',
          source: 'clustered-city-markers',
          minzoom: 10, // Only show when zoomed in past level 10
          layout: {
            'icon-image': [
              'case',
              ['==', ['get', 'kategorija'], 'Zanat'], 'pin-zanat',
              ['==', ['get', 'kategorija'], 'Proizvodi'], 'pin-proizvodi',
              ['==', ['get', 'kategorija'], 'Usluge'], 'pin-usluge',
              ['==', ['get', 'kategorija'], 'Manifestacije'], 'pin-manifestacije',
              'pin-zanat' // default
            ],
            'icon-size': 1,
            'icon-anchor': 'bottom',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true
          }
        });

        console.log('Symbol layer added with all images');
        console.log(`City clusters: ${cityClusterFeatures.length}, Individual markers: ${individualMarkers.length}`);

        // Store ALL features for search functionality (both clustered and individual)
        data.features.forEach((feature) => {
          allMarkers.push({
            properties: feature.properties,
            coordinates: feature.geometry.coordinates,
            category: feature.properties.kategorija,
          });
        });

        // Add hover effects (immediately after layer is added)
        map.on('mouseenter', 'places-symbols', (e) => {
          map.getCanvas().style.cursor = 'pointer';

          // Remove any existing tooltip
          if (currentTooltip) {
            document.body.removeChild(currentTooltip);
            currentTooltip = null;
          }

          // Create tooltip
          const properties = e.features[0].properties;
          currentTooltip = document.createElement("div");
          currentTooltip.className = "custom-tooltip";
          currentTooltip.textContent = properties.naziv;
          currentTooltip.style.cssText = `
            position: absolute;
            left: ${e.originalEvent.pageX + 8}px;
            top: ${e.originalEvent.pageY - 25}px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            z-index: 10000;
            pointer-events: none;
            max-width: 200px;
            word-wrap: break-word;
          `;
          document.body.appendChild(currentTooltip);
        });

        map.on('mouseleave', 'places-symbols', () => {
          map.getCanvas().style.cursor = '';
          if (currentTooltip) {
            document.body.removeChild(currentTooltip);
            currentTooltip = null;
          }
        });

        // Add click handler for popups
        map.on('click', 'places-symbols', (e) => {
          const coordinates = e.features[0].geometry.coordinates.slice();
          const properties = e.features[0].properties;

          // Check if popup is already open
          const existingPopup = document.querySelector(".maplibregl-popup");
          if (existingPopup) {
            existingPopup.remove();
            return;
          }

          const photos = normPhotos(properties.foto);
          popup
            .setLngLat(coordinates)
            .setHTML(popupHTML(properties))
            .addTo(map);

          // Wire up carousel if photos exist
          setTimeout(() => {
            const container = popup
              .getElement()
              .querySelector(".maplibregl-popup-content");
            if (container && photos.length > 1) {
              wireCarousel(container, photos);
            }
          }, 100);
        });

        // Add hover and click handlers for clustered city markers (same as regular markers)
        map.on('mouseenter', 'clustered-city-symbols', (e) => {
          map.getCanvas().style.cursor = 'pointer';

          if (currentTooltip) {
            document.body.removeChild(currentTooltip);
            currentTooltip = null;
          }

          const properties = e.features[0].properties;
          currentTooltip = document.createElement("div");
          currentTooltip.className = "custom-tooltip";
          currentTooltip.textContent = properties.naziv;
          currentTooltip.style.cssText = `
            position: absolute;
            left: ${e.originalEvent.pageX + 8}px;
            top: ${e.originalEvent.pageY - 25}px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            z-index: 10000;
            pointer-events: none;
            max-width: 200px;
            word-wrap: break-word;
          `;
          document.body.appendChild(currentTooltip);
        });

        map.on('mouseleave', 'clustered-city-symbols', () => {
          map.getCanvas().style.cursor = '';
          if (currentTooltip) {
            document.body.removeChild(currentTooltip);
            currentTooltip = null;
          }
        });

        map.on('click', 'clustered-city-symbols', (e) => {
          const coordinates = e.features[0].geometry.coordinates.slice();
          const properties = e.features[0].properties;

          const existingPopup = document.querySelector(".maplibregl-popup");
          if (existingPopup) {
            existingPopup.remove();
            return;
          }

          const photos = normPhotos(properties.foto);
          popup
            .setLngLat(coordinates)
            .setHTML(popupHTML(properties))
            .addTo(map);

          setTimeout(() => {
            const container = popup
              .getElement()
              .querySelector(".maplibregl-popup-content");
            if (container && photos.length > 1) {
              wireCarousel(container, photos);
            }
          }, 100);
        });

        // City cluster interaction handlers
        // Change cursor on city cluster hover
        map.on('mouseenter', 'city-clusters-circles', () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', 'city-clusters-circles', () => {
          map.getCanvas().style.cursor = '';
        });

        // Click handler for city clusters - zoom to show all markers in that city
        map.on('click', 'city-clusters-circles', (e) => {
          const features = map.queryRenderedFeatures(e.point, {
            layers: ['city-clusters-circles']
          });

          if (!features.length) return;

          const bounds = features[0].properties.bounds;

          // Parse bounds from string (stored as array in properties)
          const coordinates = JSON.parse(bounds);

          // Create bounds and fit to them
          const bbox = new maplibregl.LngLatBounds();
          coordinates.forEach(coord => bbox.extend(coord));

          map.fitBounds(bbox, {
            padding: 100,
            maxZoom: 11,
            duration: 800
          });
        });

        // Symbol layers are stable by default - no additional CSS needed

        // Autocomplete Search Functionality
        const searchInput = document.getElementById("searchInput");
        const searchBtn = document.getElementById("searchBtn");
        const searchDropdown = document.getElementById("searchDropdown");
        const filterBtns = document.querySelectorAll(".filter-btn");

        const categoryColors = {
          'Zanat': '#F4A261',
          'Proizvodi': '#8B4513',
          'Usluge': '#20B2AA',
          'Manifestacije': '#DC143C'
        };

        let currentFilter = "all";
        let highlightedIndex = -1;
        let filteredLocations = [];

        // Build locations list from allMarkers
        const allLocations = allMarkers.map((marker, index) => ({
          id: index,
          naziv: marker.properties.naziv,
          mesto: marker.properties.mesto,
          kategorija: marker.properties.kategorija,
          coordinates: marker.coordinates
        }));

        // Render dropdown items
        function renderDropdown(locations) {
          filteredLocations = locations;
          highlightedIndex = -1;

          if (locations.length === 0) {
            searchDropdown.innerHTML = '<div class="dropdown-empty">Nema rezultata</div>';
            searchDropdown.classList.add('active');
            return;
          }

          const html = locations.map((loc, index) => `
            <div class="dropdown-item" data-index="${index}">
              <span class="dropdown-item-category" style="background-color: ${categoryColors[loc.kategorija] || '#999'}"></span>
              <span class="dropdown-item-name">${loc.naziv}</span>
              <span class="dropdown-item-location">${loc.mesto}</span>
            </div>
          `).join('');

          searchDropdown.innerHTML = html;
          searchDropdown.classList.add('active');

          // Add click listeners to items
          searchDropdown.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', () => {
              const index = parseInt(item.dataset.index);
              selectLocation(filteredLocations[index]);
            });
          });
        }

        // Filter and show dropdown
        function filterDropdown() {
          const query = searchInput.value.toLowerCase().trim();

          const filtered = allLocations.filter(loc => {
            const naziv = loc.naziv.toLowerCase();
            const mesto = loc.mesto.toLowerCase();
            return naziv.includes(query) || mesto.includes(query);
          });

          renderDropdown(filtered);
        }

        // Select a location from dropdown
        function selectLocation(location) {
          searchInput.value = location.naziv;
          searchDropdown.classList.remove('active');

          // Zoom to selected location
          map.flyTo({
            center: location.coordinates,
            zoom: 14,
            duration: 1000
          });

          // Optional: Show popup for selected location
          // You can uncomment below if you want to show the popup immediately
          // const marker = allMarkers[location.id];
          // popup.setLngLat(location.coordinates).setHTML(popupHTML(marker.properties)).addTo(map);
        }

        // Hide dropdown
        function hideDropdown() {
          searchDropdown.classList.remove('active');
          highlightedIndex = -1;
        }

        // Highlight navigation
        function updateHighlight() {
          searchDropdown.querySelectorAll('.dropdown-item').forEach((item, index) => {
            if (index === highlightedIndex) {
              item.classList.add('highlighted');
              item.scrollIntoView({ block: 'nearest' });
            } else {
              item.classList.remove('highlighted');
            }
          });
        }

        // Category filtering
        function filterByCategory(category) {
          currentFilter = category;

          // Update filter buttons
          filterBtns.forEach((btn) => {
            btn.classList.remove("active");
            if (btn.dataset.category === category) {
              btn.classList.add("active");
            }
          });

          // Filter markers using symbol layer filter
          if (category === "all") {
            // Show all markers and clusters
            map.setFilter('places-symbols', null);
            map.setFilter('clustered-city-symbols', null);
            map.setFilter('city-clusters-circles', null);
            map.setFilter('city-clusters-labels', null);
          } else {
            // Filter individual markers by category
            map.setFilter('places-symbols', ['==', ['get', 'kategorija'], category]);
            map.setFilter('clustered-city-symbols', ['==', ['get', 'kategorija'], category]);

            // Filter city clusters to only show if they contain markers from this category
            // Use index-of to check if category exists in comma-separated categories string
            const categoryFilter = [
              'any',
              ['==', ['get', 'categories'], category], // Single category in cluster
              ['>', ['index-of', category, ['get', 'categories']], -1] // Category found in list
            ];
            map.setFilter('city-clusters-circles', categoryFilter);
            map.setFilter('city-clusters-labels', categoryFilter);
          }
        }

        // Event listeners for autocomplete

        // Show all locations on focus
        searchInput.addEventListener("focus", () => {
          filterDropdown();
        });

        // Filter as user types
        searchInput.addEventListener("input", () => {
          filterDropdown();
        });

        // Search button click - if there's a value, show dropdown
        searchBtn.addEventListener("click", () => {
          if (searchInput.value.trim()) {
            filterDropdown();
          } else {
            renderDropdown(allLocations);
          }
        });

        // Keyboard navigation
        searchInput.addEventListener("keydown", (e) => {
          const items = searchDropdown.querySelectorAll('.dropdown-item');

          if (e.key === "ArrowDown") {
            e.preventDefault();
            if (highlightedIndex < filteredLocations.length - 1) {
              highlightedIndex++;
              updateHighlight();
            }
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            if (highlightedIndex > 0) {
              highlightedIndex--;
              updateHighlight();
            }
          } else if (e.key === "Enter") {
            e.preventDefault();
            if (highlightedIndex >= 0 && filteredLocations[highlightedIndex]) {
              selectLocation(filteredLocations[highlightedIndex]);
            }
          } else if (e.key === "Escape") {
            hideDropdown();
            searchInput.blur();
          }
        });

        // Click outside to close dropdown
        document.addEventListener("click", (e) => {
          if (!searchInput.contains(e.target) &&
              !searchDropdown.contains(e.target) &&
              !searchBtn.contains(e.target)) {
            hideDropdown();
          }
        });

        // Category filter buttons
        filterBtns.forEach((btn) => {
          btn.addEventListener("click", () => {
            filterByCategory(btn.dataset.category);
          });
        });

        // Fullscreen/Open in new window button
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        if (fullscreenBtn) {
          fullscreenBtn.addEventListener('click', () => {
            window.open('https://niv.amityintegration.com/app.html', '_blank');
          });
        }
      }); // <-- Close map.on("load", ...) function
    </script>
  </body>
</html>
